# 高并发缓存数据一致性解决方案

> 背景
>
> 我们的一些数据存储在缓存和数据库中，对缓存读写的时候就要涉及到缓存和数据库的读写一致性问题

## 读请求的解决方案

- 先读缓存，读取不到读取数据库

### 存在问题

 - 缓存穿透

   	- 解决方案：

 - 缓存雪崩

   	- 解决方案：

 - 缓存击穿

    - 解决方案：

      

## 写请求的解决方案

- 先删除缓存，再更新数据库



### 存在问题

- 以订单为例
  - 商品有1000个库存
  - 高并发环境，A写请求购买1个商品、B读请求查询商品库存

- 问题：

  - A写请求删除商品库存缓存，还没来得及更新数据库

  - B读请求过来，发现商品库存缓存为空，去查询数据库，查到库存为1000

    修改库存缓存为1000。

  - 此时A写请求去更新数据库商品库存，更新为999。

  此时就出现了缓存和数据库数据不一致的情况。
  
  

### 解决方案

- 将A写请求和B读请求放在阻塞队列中BlockingQueue中，请求串行执行。

 此时执行顺序如下：

- 创建blockingQueue，并开启线程监听blockingQueue是否存在元素，如果是读请求，则执行读请求操作，

  如果是写请求，则执行写请求操作。

- 写请求：将写请求写入blockingQueue。

- 读请求：

  - 将读请求写入blockingQueue，写入前判断是否最后一个请求也是读请求，如果是，则此次读请求不进行写入。
  - 循环判断blockingQueue是否执行完成，如果执行完成，则再执行一次读方法。
  - 为了用户的体验感，判断循环是否超时，如果超时，则直接查询数据库返回。



### 核心代码

```java
package com.ywf.otherproject.service.impl;

import com.ywf.otherproject.entity.BuyGoodsRequest;
import com.ywf.otherproject.entity.GetGoodsStockRequest;
import com.ywf.otherproject.entity.GoodsStock;
import com.ywf.otherproject.mapper.GoodsStockMapper;
import com.ywf.otherproject.service.IGoodsStockService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.util.Iterator;
import java.util.concurrent.*;

/**
 * @Author:ywf
 */
@Service
public class GoodsStockService implements IGoodsStockService {

    private Logger logger = LoggerFactory.getLogger(GoodsStockService.class);
    private final static String GOODS_STOCK_PRE_KEY = "goodsStock:";

    @Autowired
    private GoodsStockMapper goodsStockMapper;

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 请求缓存队列
     */
    private BlockingQueue requestBlockingQueue;

    @PostConstruct
    public void init() {
        // 最大请求数设置为200
        requestBlockingQueue = new LinkedBlockingDeque(200);
        RequestConsumer requestConsumer = new RequestConsumer(requestBlockingQueue);
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(requestConsumer);
    }

    @Override
    public String buyGoods(int goodsId, int buyNum) {
        BuyGoodsRequest buyGoodsRequest = new BuyGoodsRequest();
        buyGoodsRequest.setGoodsId(goodsId);
        buyGoodsRequest.setBuyNum(buyNum);
        try {
            requestBlockingQueue.put(buyGoodsRequest);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "buyGoods success";
    }

    /**
     * 处理获取商品详情
     *
     * @param goodsId
     * @param buyNum
     */
    private void handleBuyGoods(int goodsId, int buyNum) {
        redisTemplate.delete(GOODS_STOCK_PRE_KEY + goodsId);
        // 模拟延迟修改数据库 休眠2秒
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        goodsStockMapper.buyGoods(goodsId, buyNum);
    }

    @Override
    public GoodsStock getGoodsStock(int goodsId) {
        // 加入到请求队列中
        GoodsStock goodsStock = null;
        try {
            // 判断requestBlockingQueue最后一个请求是否还是读请求
            Object lastRequest = null;
            Iterator iterator = requestBlockingQueue.iterator();
            while (iterator.hasNext()) {
                lastRequest = iterator.next();
            }
            if (null == lastRequest || !(lastRequest instanceof GetGoodsStockRequest)) {
                GetGoodsStockRequest getGoodsStockRequest = new GetGoodsStockRequest();
                getGoodsStockRequest.setGoodsId(goodsId);
                requestBlockingQueue.put(getGoodsStockRequest);
                logger.info("goodsId = " + goodsId + " 添加读请求");
            } else {
                logger.info("goodsId = " + goodsId + " 连续读请求...");
            }
            // 循环等待，设置超时时间 200ms,超过直接读取数据库
            long maxTime = 200;
            long curTime = System.currentTimeMillis();
            while (!requestBlockingQueue.isEmpty()) {
                if ((System.currentTimeMillis() - curTime) >= maxTime) {
                    goodsStock = goodsStockMapper.getDetail(goodsId);
                    if (null != goodsStock) {
                        // 不设置缓存 因为此时可能还未更新到数据库
//                        redisTemplate.opsForValue().set(GOODS_STOCK_PRE_KEY + goodsId, goodsStock);
                        return goodsStock;
                    }
                }
                TimeUnit.MILLISECONDS.sleep(10);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 队列为空
        return handleGetGoodsStock(goodsId);
    }

    /**
     * 处理获取商品库存
     *
     * @param goodsId
     * @return
     */
    private GoodsStock handleGetGoodsStock(int goodsId) {
        // 判断缓存是否存在商品
        GoodsStock goodsStock = (GoodsStock) redisTemplate.opsForValue().get(GOODS_STOCK_PRE_KEY + goodsId);
        if (null != goodsStock) {
            return goodsStock;
        }

        // 查询数据库，并设置缓存
        goodsStock = goodsStockMapper.getDetail(goodsId);

        if (null != goodsStock) {
            redisTemplate.opsForValue().set(GOODS_STOCK_PRE_KEY + goodsId, goodsStock);
        }
        return goodsStock;
    }

    class RequestConsumer implements Runnable {

        private BlockingQueue queue;

        public RequestConsumer(BlockingQueue queue) {
            this.queue = queue;
        }

        @Override
        public void run() {
            while (true) {
                if (!queue.isEmpty()) {
                    try {                     
                        Object obj = queue.take();
                        if (obj instanceof BuyGoodsRequest) {
                            BuyGoodsRequest request = (BuyGoodsRequest) obj;
                            logger.info("执行写请求:" + " goodsId = " + request.getGoodsId() + ", buyNum = " + request.getBuyNum());
                            // 执行写操作
                            handleBuyGoods(request.getGoodsId(), request.getBuyNum());
                        } else if (obj instanceof GetGoodsStockRequest) {
                            GetGoodsStockRequest request = (GetGoodsStockRequest) obj;
                            logger.info("执行读请求:" + " goodsId = " + request.getGoodsId());
                            // 执行读操作
                            handleGetGoodsStock(request.getGoodsId());
                        }
                        TimeUnit.MILLISECONDS.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```

